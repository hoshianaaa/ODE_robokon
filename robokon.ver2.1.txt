//知能ロボコン用のシミュレーション
//log 2018/08/11 機体の描画
//log 2018/09/01 後輪の追加,前輪の位置調整（実行できない)



#include <ode/ode.h>                            // ODE用ヘッダーファイル
#include <drawstuff/drawstuff.h>                // 描画用ヘッダーファイル

#ifdef dDOUBLE
#define dsDrawSphere dsDrawSphereD
#define dsDrawCylinder dsDrawCylinderD
#define dsDrawBox dsDrawBoxD
#endif

static dWorldID world;                          //動力学計算用ワールド
static dSpaceID space;                          //衝突検出用スペース
static dGeomID  ground;
static dJointID joint[3];
static dJointGroupID contactgroup;              //コンタクトグループ
static int flag = 0;                            //
dsFunctions fn;                                 //


const dReal   WH_R = 0.1;                       //車輪の半径
const dReal   WH_W = 0.05;                      //車輪の幅
const dReal   WH_M   = 1.0;                     //車輪の質量
const dReal   WH2_R = 0.02;
const dReal   WH2_W = 0.02;
const dReal   WH2_M = 0.2;
dReal BASE_M = 9.4;                             //台車の質量
dReal BASE_S[3] = {0.6,0.4,0.2};                //台車のサイズ
dReal START_X = 0, START_Y = 0, START_Z = 0.2;  //初期位置

typedef struct {                                // MyObject 構造体
  dBodyID body;                                 // ボディ（剛体）のID番号（動力学計算用）
  dGeomID geom;                                 // ジオメトリのID番号（衝突検出用計算）
} MyObject;

MyObject wheel[3],base;


// コールバック関数
static void nearCallback(void *data, dGeomID o1, dGeomID o2)
{
  const int N = 10;                             // 接触点数の最大値
  dContact contact[N];                          // 接触点


  // 接触している物体のどちらかが地面ならisGroundに非0をセット
  int isGround = ((ground == o1) || (ground == o2));

  // 衝突情報の生成　n　は衝突点数
  int n =  dCollide(o1,o2,N,&contact[0].geom,sizeof(dContact));
  if (isGround)  {
		if (n >= 1) flag = 1;
    else        flag = 0;
    for (int i = 0; i < n; i++) {
      contact[i].surface.mode = dContactBounce;  // 接触面の反発係数を設定
      contact[i].surface.mu   = dInfinity;
      contact[i].surface.bounce     = 0.0;       //　反発係数
      contact[i].surface.bounce_vel = 0.0;       // 反発最低速度
      // 接触ジョイントの生成
      dJointID c = dJointCreateContact(world,contactgroup,&contact[i]);
      // 接触している2つの剛体を接触ジョイントにより高速
      dJointAttach (c,dGeomGetBody(contact[i].geom.g1),dGeomGetBody(contact[i].geom.g2));
    }
  }
}

// シミュレーションループ
static void simLoop (int pause)
{
  const dReal *pos,*R;

  flag = 0;
  dSpaceCollide(space,0,&nearCallback);     // 衝突検出関数
  dWorldStep(world,0.01);
  dJointGroupEmpty(contactgroup);           // ジョイントグループを空にする


  for(int i = 0; i < 2 ; i++){
    dsSetColor(1.0, 0.0, 0.0);
    dsDrawCylinder(dBodyGetPosition(wheel[i].body),dBodyGetRotation(wheel[i].body),WH_W,WH_R);
  }
    dsSetColor(0.0, 1.0, 0.0);
    dsDrawBox(dBodyGetPosition(base.body),dBodyGetRotation(base.body),BASE_S);

    //後輪
    dsSetColor(1.0, 0.0, 0.0);
    dsDrawCylinder(dBodyGetPosition(wheel[2].body),dBodyGetRotation(wheel[2].body),WH2_W,WH2_R);
}

void start()                                       /*** 前処理 ***/
{
  static float xyz[3] = {-2.0,0.0,0.4};            // 視点の位置
  static float hpr[3] = {0.0,0.0,0.0};             // 視点の方向
  dsSetViewpoint (xyz,hpr);
}

void  prepDrawStuff() {                             // 描画関数の設定
  fn.version = DS_VERSION;
  fn.start   = &start;
  fn.step    = &simLoop;
  fn.command = NULL;
  fn.stop    = NULL;
  fn.path_to_textures = "../../drawstuff/textures";
}

int main (int argc, char *argv[])
{

  dMass mass;
  dMatrix3 R;
  dReal angle = M_PI/2;

  prepDrawStuff();

  dInitODE();
  world = dWorldCreate();
  space = dHashSpaceCreate(0);
  contactgroup = dJointGroupCreate(0);

    dWorldSetGravity(world,0,0,-0.5);

  // Create a ground
  ground = dCreatePlane(space,0,0,1,0);

  // 車体
  base.body = dBodyCreate(world);                                       // ワールドにボディを生成
  dMassSetZero(&mass);                                                  // 質量パラメータの初期化
  dMassSetBoxTotal(&mass, BASE_M, BASE_S[0], BASE_S[1], BASE_S[2]);     // 質量パラメータの計算
  dBodySetMass(base.body, &mass);                                       // 質量パラメータの設定
  base.geom = dCreateBox(space, BASE_S[0], BASE_S[1], BASE_S[2]);       // ジオメトリの生成
  dGeomSetBody(base.geom, base.body);                                   // ジオメトリとボディの関連付け
  dBodySetPosition(base.body, START_X, START_Y, START_Z);               //　ボディの初期位置の設定

  // 車輪
  dRFromAxisAndAngle(R,1,0,0,angle);                                    // 回転行列の生成
  for (int i = 0; i < 2; i++) {
      wheel[i].body = dBodyCreate(world);                               // ボディの生成
      dMassSetZero(&mass);                                              // 質量パラメータの初期化
      dMassSetCylinderTotal(&mass, WH_M, 1, WH_R, WH_W);                // 質量パラメータの計算
      dBodySetMass(wheel[i].body, &mass);                               // 質量パラメータの設定
      wheel[i].geom = dCreateCylinder(space, WH_R, WH_W);               // ジオメトリの生成
      dGeomSetBody(wheel[i].geom, wheel[i].body);                       // ボディとジオメトリの関連付け
      dBodySetRotation(wheel[i].body, R);                               // ボディの初期姿勢の設定
  }
  // 後輪
      wheel[2].body = dBodyCreate(world);                               // ボディの生成
      dMassSetZero(&mass);                                              // 質量パラメータの初期化
      dMassSetCylinderTotal(&mass, WH2_M, 1, WH2_R, WH2_W);                // 質量パラメータの計算
      dBodySetMass(wheel[2].body, &mass);                               // 質量パラメータの設定
      wheel[2].geom = dCreateCylinder(space, WH2_R, WH2_W);               // ジオメトリの生成
      dGeomSetBody(wheel[2].geom, wheel[2].body);                       // ボディとジオメトリの関連付け
      dBodySetRotation(wheel[2].body, R);


  dReal w0x = BASE_S[0] / 3;
  dReal w0y = (BASE_S[1] + WH_W) / 2;                                   // wheel[0]のy座標
  dReal w0z = WH_R;                                                     // wheel[0]のｚ座標
  dReal w2x = -(BASE_S[0] / 3);
  dReal w2y = 0;                                                        // wheel[2]のy座標
  dReal w2z = WH2_R;                                                    // wheel[2]のz座標
                                                                                                        // wheel[1]のｚ座標
  dBodySetPosition(wheel[0].body, w0x, w0y, w0z);                        // wheel[0]の座標の設定
  dBodySetPosition(wheel[1].body, w0x, -w0y, w0z);                       // wheel[1]の座標の設定
  dBodySetPosition(wheel[0].body, w2x, w2y, w2z);                        // wheel[2]の座標の設定




  //ジョイント
  for (int  i = 0; i < 3; i++){
    joint[i] = dJointCreateHinge(world, 0);
    dJointAttach(joint[i], base.body, wheel[i].body);
  }
  dJointSetHingeAxis(joint[0], 0, 1, 0);
  dJointSetHingeAxis(joint[1], 0, 1, 0);
  dJointSetHingeAxis(joint[2], 0, 1, 0);
  dJointSetHingeAnchor(joint[0],   w0x, w0y, w0z);
  dJointSetHingeAnchor(joint[1],   w0x, -w0y, w0z);
  dJointSetHingeAnchor(joint[1],   w2x, -w2y, w2z);




  dsSimulationLoop (argc,argv,352,288,&fn);

  dWorldDestroy (world);
  dCloseODE();

  return 0;
}
